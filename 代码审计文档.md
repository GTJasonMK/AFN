# AFN 项目代码审计报告

**审计日期**: 2025-12-20
**审计范围**: backend/ 和 frontend/
**审计标准**: DDD、SOLID、性能优化、代码健壮性

---

## 1. 关键风险 (Critical Issues)

### Issue #1: 方法内部重复创建服务实例
**位置**: `backend/app/services/llm_service.py` 第 188 行
**问题**: `get_summary` 方法每次调用都会创建新的 `PromptService` 实例，违反依赖注入原则，导致不必要的对象创建开销。
```python
async def get_summary(self, chapter_content: str, ...) -> str:
    if not system_prompt:
        prompt_service = PromptService(self.session)  # 每次调用都创建新实例
        system_prompt = await prompt_service.get_prompt("extraction")
```
**建议**: 通过构造函数注入 `PromptService`，或在 `__init__` 中初始化为实例属性：
```python
def __init__(self, session, prompt_service: PromptService = None):
    self.session = session
    self.prompt_service = prompt_service or PromptService(session)
```

### Issue #3: 循环内部导入模块（性能陷阱）
**位置**: `backend/app/services/chapter_generation/service.py` 第 355-357 行
**问题**: 在循环体内部进行模块导入，每次迭代都会执行导入检查，造成不必要的性能开销。
```python
for existing in all_chapters:
    # ...
    if existing.chapter_number > latest_prev_number:
        # 导入extract_tail_excerpt函数 -- 这行在循环内！
        from ...utils.writer_helpers import extract_tail_excerpt
        previous_tail_excerpt = extract_tail_excerpt(existing.selected_version.content)
```
**建议**: 将导入语句移动到文件顶部或方法开始处：
```python
from ...utils.writer_helpers import extract_tail_excerpt  # 移到文件顶部

# 然后在循环中直接使用
for existing in all_chapters:
    previous_tail_excerpt = extract_tail_excerpt(existing.selected_version.content)
```

### Issue #5: update_fields 无法将字段设置为 None（边界条件缺陷）
**位置**: `backend/app/repositories/base.py` 第 96-102 行
**问题**: `update_fields` 方法使用 `if value is None: continue` 跳过 None 值，导致无法将字段显式设置为 None。
```python
async def update_fields(self, instance: ModelType, **values: Any) -> ModelType:
    for key, value in values.items():
        if value is None:  # 这会阻止将字段设置为 None
            continue
        setattr(instance, key, value)
    await self.session.flush()
    return instance
```
**建议**: 使用哨兵对象区分"未传递"和"显式传递None"：
```python
_UNSET = object()  # 哨兵值

async def update_fields(self, instance: ModelType, **values: Any) -> ModelType:
    for key, value in values.items():
        if value is _UNSET:  # 只跳过未传递的参数
            continue
        setattr(instance, key, value)  # None 值也会被正确设置
    await self.session.flush()
    return instance
```

---

## 2. 冗余与优化 (Redundancy & Cleanup)

### Issue #2: 不可达的死代码
**位置**: `backend/app/services/llm_service.py` 第 407-413 行
**问题**: for 循环的所有分支要么 `return`，要么 `raise`，要么 `continue`，循环结束后的代码逻辑上不可达。
```python
for attempt in range(max_retries + 1):
    try:
        # ... return result.content  # 成功时返回
    except InternalServerError:
        raise LLMServiceError(...)  # 抛出异常
    except (...) as exc:
        if attempt < max_retries:
            continue  # 继续重试
        raise LLMServiceError(...) from exc  # 最后一次也抛出
    except Exception:
        raise LLMServiceError(...)  # 抛出异常

# 以下代码不可达
if last_error:
    raise LLMServiceError(...)
raise LLMServiceError("未知错误")
```
**建议**: 删除第 407-413 行的死代码，或者重构为使用 `for-else` 结构使意图更清晰。

### Issue #4: 重复的异常处理逻辑（DRY 违反）
**位置**: `frontend/api/client/core.py` 第 232-311 行 与 第 353-381 行
**问题**: `_request` 和 `_request_raw` 方法中有大量重复的异常处理逻辑，违反 DRY 原则。
```python
# _request 方法中：
except requests.exceptions.ConnectionError as e:
    logger.error(f"API连接失败: {method} {url} - {e}")
    raise APIConnectionError(message="无法连接到后端服务...", original_error=e)

# _request_raw 方法中（几乎相同）：
except requests.exceptions.ConnectionError as e:
    logger.error(f"API连接失败: {method} {url} - {e}")
    raise APIConnectionError(message="无法连接到后端服务", original_error=e)
```
**建议**: 提取公共的异常处理逻辑到装饰器或私有方法：
```python
def _handle_request_exception(self, e: Exception, method: str, url: str, read_timeout: int):
    """统一的异常处理逻辑"""
    if isinstance(e, requests.exceptions.ConnectionError):
        logger.error("API连接失败: %s %s - %s", method, url, e)
        raise APIConnectionError(message="无法连接到后端服务", original_error=e)
    # ... 其他异常处理
```

---

## 3. 架构重构建议 (Refactoring Roadmap)

### Issue #6: 方法内部创建服务实例（多处违反依赖注入）
**位置**:
- `backend/app/services/manga_prompt/core.py` 第 151 行
- `backend/app/services/chapter_generation/service.py` 第 167-168, 177, 194 行
**问题**: 在方法内部创建服务实例，导致：
1. 无法进行单元测试（无法Mock依赖）
2. 违反控制反转原则（IoC）
3. 服务生命周期管理混乱
```python
# manga_prompt/core.py 第151行
async def generate_manga_prompts(...):
    # ...
    image_service = ImageGenerationService(self.session)  # 每次调用都创建

# chapter_generation/service.py 第167-168行
async def prepare_generation_context(...):
    from ..foreshadowing_service import ForeshadowingService
    from ..chapter_context_service import EnhancedChapterContextService
    # ...
    foreshadowing_service = ForeshadowingService(self.session)  # 第177行
    enhanced_context_service = EnhancedChapterContextService(...)  # 第194行
```
**建议**: 采用统一的依赖注入模式。方案A - 构造函数注入：
```python
class MangaPromptService:
    def __init__(self, session, llm_service, prompt_service, image_service):
        self.image_service = image_service

class ChapterGenerationService:
    def __init__(self, session, llm_service, foreshadowing_service, context_service):
        self.foreshadowing_service = foreshadowing_service
        self.context_service = context_service
```
方案B - 使用依赖容器（在 `core/dependencies.py` 中统一管理）。

### Issue #7: QObject 单例模式的反模式实现
**位置**: `frontend/themes/theme_manager/core.py` 第 42-51 行
**问题**: 在 `__new__` 中调用 `QObject.__init__()` 是反模式，可能导致：
1. 多重继承时的MRO（方法解析顺序）问题
2. PyQt6的对象生命周期管理混乱
3. 代码可读性差
```python
def __new__(cls):
    if cls._instance is None:
        cls._instance = super().__new__(cls)
        # 不应该在__new__中调用__init__
        QObject.__init__(cls._instance)  # 反模式！
        cls._instance._current_mode = ThemeMode.LIGHT
        # ...
    return cls._instance

def __init__(self):
    pass  # 空的__init__，容易造成混淆
```
**建议**: 方案A - 使用元类或装饰器实现单例；方案B - 直接使用模块级实例（当前第125行已有），移除类内单例逻辑：
```python
class ThemeManager(ThemePropertiesMixin, ..., QObject):
    def __init__(self):
        super().__init__()  # 正常的初始化链
        self._current_mode = ThemeMode.LIGHT
        self._current_theme = LightTheme
        self._config_manager = None

# 模块级单例（推荐）
_theme_manager_instance = None

def get_theme_manager() -> ThemeManager:
    global _theme_manager_instance
    if _theme_manager_instance is None:
        _theme_manager_instance = ThemeManager()
    return _theme_manager_instance
```

### Issue #8: 工具函数违反分层架构（直接抛出HTTPException）
**位置**: `backend/app/utils/json_utils.py` 第 135-204 行 (`parse_llm_json_or_fail`)
**问题**: 工具层函数直接抛出 `HTTPException`，违反了分层架构原则。`utils/` 模块不应该知道HTTP层的存在。
```python
from fastapi import HTTPException  # 工具模块不应该依赖 FastAPI

def parse_llm_json_or_fail(...) -> Dict[str, Any]:
    try:
        # ...
    except json.JSONDecodeError as exc:
        # 直接抛出 HTTPException，耦合了HTTP层
        raise HTTPException(
            status_code=status_code,
            detail=user_message
        ) from exc
```
**建议**: 工具函数应该抛出业务异常（`exceptions.py` 中已定义的 `JSONParseError`），让路由层负责转换为HTTP响应：
```python
# json_utils.py
from ..exceptions import JSONParseError

def parse_llm_json_or_fail(raw_text: str, error_context: str) -> Dict[str, Any]:
    try:
        # ...
    except json.JSONDecodeError as exc:
        raise JSONParseError(
            context=error_context,
            detail_msg=f"{exc.msg} (行{exc.lineno} 列{exc.colno})"
        ) from exc

# router 层：全局异常处理器会自动转换 JSONParseError -> HTTPException
```

### Issue #9: ImageGenerationService 违反单一职责原则（SRP）
**位置**: `backend/app/services/image_generation/service.py` 第 76-598 行
**问题**: `ImageGenerationService` 类承担了两个不同的职责：
1. 配置管理（CRUD操作）：第87-223行
2. 图片生成（业务逻辑）：第227-598行

这违反了SRP原则，导致：
- 类过大（~520行），难以维护
- 配置变更和生成逻辑耦合
- 单元测试困难
```python
class ImageGenerationService:
    # ==================== 配置管理 ====================  (应该独立)
    async def get_configs(...)
    async def create_config(...)
    async def update_config(...)
    async def delete_config(...)
    async def activate_config(...)
    async def test_config(...)

    # ==================== 图片生成 ====================  (核心职责)
    async def generate_image(...)
    async def get_scene_images(...)
    async def delete_image(...)
```
**建议**: 拆分为两个服务：
```python
# image_config_service.py
class ImageConfigService:
    """图片生成配置管理服务"""
    async def get_configs(...)
    async def create_config(...)
    async def activate_config(...)
    # ...

# image_generation_service.py
class ImageGenerationService:
    """图片生成服务"""
    def __init__(self, session, config_service: ImageConfigService):
        self.config_service = config_service

    async def generate_image(...)
    async def get_scene_images(...)
    # ...
```

### Issue #10: WritingDesk 页面类过大（上帝类倾向）
**位置**: `frontend/windows/writing_desk/main.py` 整个文件（~905行）
**问题**: `WritingDesk` 类承担了过多职责，接近"上帝类"(God Class)：
1. UI初始化和布局管理
2. 项目数据加载
3. 章节生成（含SSE流式处理）
4. 提示词预览
5. 内容保存
6. RAG入库
7. 版本选择/评审
8. 导出功能
9. 进度对话框管理

共约40个方法，严重违反SRP原则。
```python
class WritingDesk(BasePage):
    # ~40个方法，905行代码
    def onGenerateChapter(...)      # 章节生成
    def onPreviewPrompt(...)        # 提示词预览
    def onSaveContent(...)          # 内容保存
    def onRagIngest(...)            # RAG入库
    def onSelectVersion(...)        # 版本选择
    def onEvaluateChapter(...)      # 章节评审
    def exportNovel(...)            # 导出功能
    # ... 还有很多回调方法
```
**建议**: 使用Mixin架构或组合模式拆分：
```python
# 方案A: Mixin拆分（与API客户端、主题管理器风格一致）
class ChapterGenerationMixin:
    """章节生成相关方法"""
    def onGenerateChapter(...)
    def _on_chapter_gen_progress(...)
    def _on_chapter_gen_complete(...)

class ContentManagementMixin:
    """内容管理相关方法"""
    def onSaveContent(...)
    def onRagIngest(...)
    def onEditContent(...)

class WritingDesk(ChapterGenerationMixin, ContentManagementMixin, BasePage):
    ...

# 方案B: 委托模式
class WritingDesk(BasePage):
    def __init__(self, ...):
        self.chapter_gen_handler = ChapterGenerationHandler(self)
        self.content_handler = ContentManagementHandler(self)
```

### Issue #11: 方法内部重复导入（多处）
**位置**:
- `frontend/windows/writing_desk/main.py` 第 234, 362-365, 555, 570, 609, 632, 774 行
- `backend/app/services/image_generation/service.py` 第 335, 474 行
**问题**: 在方法内部导入模块，每次方法调用都会执行导入检查：
```python
def onPreviewPrompt(self, ...):
    from components.dialogs import TextInputDialog  # 第234行
    from PyQt6.QtWidgets import QDialog, ...        # 第363行
    from themes.theme_manager import theme_manager  # 第364行 (已在文件顶部导入！)

def onSaveContentSuccess(self, ...):
    from components.dialogs import AlertDialog      # 第555行
```
**建议**: 将所有导入移动到文件顶部。如果是为了避免循环导入，使用 `TYPE_CHECKING` 模式：
```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from components.dialogs import AlertDialog

# 运行时导入（仅在真正需要延迟导入时使用）
def onSaveContentSuccess(self, ...):
    from components.dialogs import AlertDialog  # 延迟导入
```

---

## 4. 审计总结

### 按严重程度分类

| 优先级 | Issue | 影响 |
|--------|-------|------|
| P0-关键 | #5 update_fields边界条件 | 可能导致数据错误 |
| P0-关键 | #8 工具函数违反分层 | 架构污染 |
| P1-高 | #1, #6 依赖注入违反 | 测试困难、耦合高 |
| P1-高 | #9, #10 SRP违反 | 维护困难 |
| P2-中 | #2 死代码 | 代码混乱 |
| P2-中 | #4 DRY违反 | 重复维护 |
| P3-低 | #3, #11 循环/方法内导入 | 轻微性能影响 |
| P3-低 | #7 单例反模式 | 可读性差 |

### 重构优先级建议

1. **立即修复**（风险高、改动小）：
   - Issue #5: 修改 `update_fields` 方法
   - Issue #2: 删除死代码

2. **短期改进**（1-2周）：
   - Issue #8: 重构 `parse_llm_json_or_fail`
   - Issue #3, #11: 统一导入位置
   - Issue #4: 提取公共异常处理

3. **中期重构**（1-2个月）：
   - Issue #9: 拆分 `ImageGenerationService`
   - Issue #1, #6: 统一依赖注入模式

4. **长期优化**：
   - Issue #10: 拆分 `WritingDesk`
   - Issue #7: 优化单例模式

---

*审计完成。发现 11 个问题，涵盖依赖注入、单一职责、代码冗余、边界条件等方面。*